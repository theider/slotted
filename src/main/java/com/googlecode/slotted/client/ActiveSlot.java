/*
 * Copyright 2012 Jeffrey Kleiss
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.googlecode.slotted.client;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;

import com.google.gwt.activity.shared.Activity;
import com.google.gwt.activity.shared.ActivityMapper;
import com.google.gwt.core.client.Callback;
import com.google.gwt.user.client.ui.AcceptsOneWidget;
import com.google.gwt.user.client.ui.IsWidget;
import com.google.web.bindery.event.shared.EventBus;
import com.google.web.bindery.event.shared.ResettableEventBus;
import com.googlecode.slotted.client.ActivityCache.Entry;
import com.googlecode.slotted.client.SlottedController.RootSlotImpl;

/**
 * An internal object that holds all the data needed to correctly display a Slot.  This shouldn't be used outside
 * of the framework.
 */
public class ActiveSlot {
    /**
     * Wraps our real display to prevent an old Activity from displaying it's contents, after it is no longer
     * active.
     */
    private class ProtectedDisplay implements AcceptsOneWidget {
        private final Activity activity;
        private boolean backgroundable;
        private boolean loading = false;
        private IsWidget view;
        private boolean widgetShown = false;

        ProtectedDisplay(Activity activity, boolean backgroundable) {
            this.activity = activity;
            this.backgroundable = backgroundable;
        }

        public void setWidget(IsWidget view) {
            this.view = view;
            if (!loading) {
                activityStarting = false;
            }
            if (widgetShown && this.activity == ActiveSlot.this.activity) {
                showWidget();
            }
        }

        private void showWidget() {
            widgetShown = true;
            if (view != null) {
                slot.showView(view, activity, backgroundable);
                activityStarting = false;
            }
        }
    }

    private ActiveSlot parent;
    private ArrayList<ActiveSlot> children = new ArrayList<ActiveSlot>();
    private Slot slot;
    private SlottedPlace place;
    private SlottedPlace newPlace;
    private Activity activity;
    private boolean activityStarting;
    private ProtectedDisplay currentProtectedDisplay;
    private SlottedController slottedController;
    private HistoryMapper historyMapper;
    private ResettableEventBus resettableEventBus;

    public ActiveSlot(ActiveSlot parent, Slot slot, EventBus eventBus,
            SlottedController slottedController)
    {
        this.parent = parent;
        this.slot = slot;
        this.slottedController = slottedController;
        this.historyMapper = slottedController.getHistoryMapper();
        this.resettableEventBus = new ResettableEventBus(eventBus);
    }

    /**
     * Checks this Slot and child Slots to see if the current Place equals the replacement Place.  If they are the same
     * nothing is done, but if the aren't equal then {@link Activity#mayStop()}, is called to determine if the Activity
     * has a warning navigating away.
     *
     * @param newPlaces All the Places that will be navigated to, which is used to determine if the current Place
     *                  equals replacement Place.
     * @param reloadAll If true, it ignores the Place equals and calls mayStop()
     * @param warnings The list of warnings that are generated by mayStop() calls.
     */
    public void maybeGoTo(Iterable<SlottedPlace> newPlaces, boolean reloadAll, ArrayList<String> warnings) {
        ActivityCache activityCache = slottedController.getActivityCache();
        boolean checkMayStop = false;
        newPlace = getPlace(newPlaces);

        List<Class<? extends SlottedPlace>> placesOfActivitiesToCache = historyMapper.getPlacesOfActivitiesToCache(newPlace);
        activityCache.markForBackground(placesOfActivitiesToCache);
        if (place != null && activityCache.isMarkedForBackground(place)) {
            placesOfActivitiesToCache = historyMapper.getPlacesOfActivitiesToCache(place);
            activityCache.markForBackground(placesOfActivitiesToCache);
        }

        if (reloadAll || !newPlace.equals(place)) {
            checkMayStop = true;
            reloadAll = true;
        }
        if (children != null) {
            for (ActiveSlot child : children) {
                child.maybeGoTo(newPlaces, reloadAll, warnings);
            }
        }

        //Children should be checked before parent in case child mayStop() saves data.
        if (checkMayStop) {
            if (place != null) {
                maybeGoToBackgroundedActivities(place, warnings, activityCache);
            }

            if (activity != null) {
                String warning = null;
                if (activityCache.isMarkedForBackground(place)) {
                    if (activity instanceof SlottedActivity) {
                        warning = ((SlottedActivity) activity).mayBackground();
                    }
                } else {
                    warning = activity.mayStop();
                }
                if (warning != null) {
                    warnings.add(warning);
                }
            }
        }
    }

    public void maybeGoToBackgroundedActivities(SlottedPlace place, ArrayList<String> warnings, ActivityCache activityCache) {
        List<Class<? extends SlottedPlace>> placesOfActivitiesToCache = historyMapper.getPlacesOfActivitiesToCache(place);
        List<Entry> backgroundedActivities = activityCache.getBackgroundedActivities(placesOfActivitiesToCache);
        for (Entry entry: backgroundedActivities) {
            maybeGoToBackgroundedActivities(entry.place, warnings, activityCache);

            String warning = entry.activity.mayStop();
            if (warning != null) {
                warnings.add(warning);
            }
        }
    }

    /**
     * Finds the ActiveSlot by determining if this ActiveSlot has the slotToFind or checking the children recursively.
     *
     * @param slotToFind The Slot instance that an ActiveSlot represents.
     * @return The ActiveSlot, or null if the slotToFind isn't in the hierarchy
     */
    public ActiveSlot findSlot(Slot slotToFind) {
        ActiveSlot found = null;
        if (slotToFind == null) {
            found = null;
        } else if (slotToFind.equals(slot)) {
            found = this;
        } else if (children != null) {
            Iterator<ActiveSlot> childIt = children.iterator();
            while (found == null && childIt.hasNext()) {
                ActiveSlot child = childIt.next();
                found = child.findSlot(slotToFind);
            }
        }
        return found;
    }

    /**
     * Stops the current Activity and all child Activities.  It also resets the EventBus to prevent memory leaks.
     */
    public void stopActivities() {
        boolean backgrounded = false;
        try {
            ActivityCache activityCache = slottedController.getActivityCache();
            if (activity != null) {
                if (activityCache.isMarkedForBackground(place)) {
                    backgrounded = true;
                    activityCache.setBackgrounded(place);
                    if (activity instanceof SlottedActivity) {
                        ((SlottedActivity) activity).onBackground();
                    }
                } else if (activityStarting) {
                    activity.onCancel();
                    activityCache.removeStopped(activity);
                } else {
                    activity.onStop();
                    activityCache.removeStopped(activity);
                }
                activity = null;
                activityStarting = false;
            }
            if (children != null) {
                for (ActiveSlot child : children) {
                    child.stopActivities();
                }
                children.clear();
            }

            if (!backgrounded && place != null) {
                stopBackgroundActivities(place, activityCache);
            }

            place = null;
            currentProtectedDisplay = null;
        } finally {
            if (!backgrounded) {
                resettableEventBus.removeHandlers();
            }
        }
    }

    private void stopBackgroundActivities(SlottedPlace place, ActivityCache activityCache) {
        List<Class<? extends SlottedPlace>> placesOfActivitiesToCache = historyMapper.getPlacesOfActivitiesToCache(place);
        List<Entry> backgroundedActivities = activityCache.getBackgroundedActivities(placesOfActivitiesToCache);
        for (Entry entry: backgroundedActivities) {
            stopBackgroundActivities(entry.place, activityCache);
            entry.activity.onStop();
        }
    }

    /**
     * Constructs the new hierarchy determining if the current Activity will change.  If it will change onStop() is called,
     * and the new Activity is constructed and start() called.  If it doesn't change, onRefresh() is called.
     *
     * @param parameters The global parameters object that should be populated during construction.
     * @param newPlaces The list of Places that will be displayed in the hierarchy.
     * @param reloadAll Will force all the Activities to be stopped and started.
     */
    public void constructStopStart(PlaceParameters parameters,
            Iterable<SlottedPlace> newPlaces, boolean reloadAll)
    {
        if (newPlace == null) {
            newPlace = getPlace(newPlaces);
        }
        historyMapper.extractParameters(newPlace, parameters);
        newPlace.setPlaceParameters(parameters);

        if (currentProtectedDisplay != null && !currentProtectedDisplay.widgetShown) {
            // DelayedLoading might have error, so force reload to prevent UI from appearing hung.
            reloadAll = true;
        }
        if (reloadAll || !newPlace.equals(place)) {
            stopActivities();
        }
        place = newPlace;
        newPlace = null;

        createChildren();

        if (slottedController.shouldStartActivity()) {
            ActivityCache activityCache = slottedController.getActivityCache();
            if (activity == null) {
                activity = activityCache.get(place);
                if (activity == null) {
                    getStartActivity(parameters);
                } else {
                    foregroundActivity(parameters);
                }
            } else {
                activityCache.get(place);
                refreshActivity(parameters);
            }
        }

        for (ActiveSlot child : children) {
            child.constructStopStart(parameters, newPlaces, reloadAll);
        }
    }

    /**
     * Gets the appropriate Place for this Slot.
     *
     * @param newPlaces The list of new Places that will be displayed.
     * @return The Place that should be displayed for this Slot
     */
    private SlottedPlace getPlace(Iterable<SlottedPlace> newPlaces) {
        for (SlottedPlace place : newPlaces) {
            boolean isRootPlace =
                    place.getParentSlot() == null || place.getParentSlot() instanceof RootSlotImpl;
            boolean isRoot = slot.getOwnerPlace() == null;
            if (isRootPlace && isRoot) {
                return place;
            }
            if (slot.equals(place.getParentSlot())) {
                return place;
            }
        }
        if (place != null) {
            return place;
        }
        return slot.getDefaultPlace();
    }

    /**
     * Gets and starts the Activity for the Place specified in class variable, and recursive calls this for its children.
     * Getting the Activity is done by checking the Place, then checking the LegacyActivityMapper.  It also creates a new
     * ResettableEventBus.
     *
     * @param parameters The global parameters for the hierarchy
     */
    private void getStartActivity(final PlaceParameters parameters) {
        Callback<Activity, Throwable> activityCallback = new Callback<Activity, Throwable>() {
            @Override public void onSuccess(Activity result) {
                try {
                    if (slottedController.asyncActivities.contains(this)) {
                        if (result != null) {
                            startActivity(result, parameters);
                        } else {
                            getStartFromMapper(parameters);
                        }
                        slottedController.asyncActivities.remove(this);
                        slottedController.asyncGoToCleanup(true);
                    } else {
                        throw new IllegalStateException("Invalid load");
                    }
                } catch (Exception e) {
                    slottedController.handleGoToException(e);
                }

            }

            @Override public void onFailure(Throwable reason) {
                slottedController.handleGoToException(reason);
            }
        };

        slottedController.asyncActivities.add(activityCallback);
        Class codeSplitClass = historyMapper.getCodeSplitMapper(place);
        if (codeSplitClass != null) {
            CodeSplitMapper codeSplitMapper = slottedController.getCodeSplitMapper(codeSplitClass);
            if (codeSplitMapper == null) {
                throw new SlottedException("CodeSplitMapper not registered:" + codeSplitClass.getName());
            }
            codeSplitMapper.get(place, activityCallback);

        } else {
            place.getActivity(activityCallback);
        }
    }

    private void getStartFromMapper(final PlaceParameters parameters) {
        ActivityMapper mapper = slottedController.getLegacyActivityMapper();
        if (mapper == null) {
            throw new IllegalStateException(historyMapper.getPlaceName(place.getClass()) + "'s getActivity() returned null, " +
                    "and LegacyActivityMapper wasn't set.");
        }
        activity = mapper.getActivity(place);
        if (activity == null) {
            throw new IllegalStateException(historyMapper.getPlaceName(place.getClass()) + "'s getActivity() returned null, " +
                    "and LegacyActivityMapper also return null.");
        }

        startActivity(activity, parameters);
    }

    private void startActivity(Activity activity, PlaceParameters parameters) {
        this.activity = activity;

        ActivityCache activityCache = slottedController.getActivityCache();
        activityCache.add(place, activity);
        List<Class<? extends SlottedPlace>> placesOfActivitiesToCache = historyMapper.getPlacesOfActivitiesToCache(place);
        activityCache.markForBackground(placesOfActivitiesToCache);

        if (activity instanceof SlottedActivity) {
            ((SlottedActivity) activity).init(slottedController, place, parameters,
                    resettableEventBus, this);
        }
        com.google.gwt.event.shared.ResettableEventBus legacyBus =
                new com.google.gwt.event.shared.ResettableEventBus(resettableEventBus);
        activityStarting = true;
        currentProtectedDisplay = new ProtectedDisplay(activity, activityCache.isMarkedForBackground(place));
        try {
            activity.start(currentProtectedDisplay, legacyBus);
        } catch (Exception e) {
            String token = historyMapper.createToken(place);
            try {
                // Start caused an exception, so attempt to clean up Activity.
                stopActivities();
            } catch (Exception stopException) {
                SlottedController.log.log(Level.WARNING,
                        "Activity.start() threw an exception and then Activity.onStop()/onCancel() threw:", stopException);
            }
            throw new SlottedInitException(token, e);
        }

        if (activity instanceof SlottedActivity) {
            for (ActiveSlot child: children) {
                Slot slot = child.getSlot();
                AcceptsOneWidget display = ((SlottedActivity) activity).getChildSlotDisplay(slot);
                if (display == null) {
                    throw new IllegalStateException(activity + " didn't correctly set the display for a Slot.");
                } else {
                    //noinspection deprecation
                    slot.setDisplay(display);
                }
            }
        } else if (!children.isEmpty()) {
            throw new IllegalStateException(place + " needs to an instance of SlottedActivity, because " +
                    "it has child slots.");
        }
        slottedController.attemptShowViews();
    }

    /**
     * Handles showing the background view and calling onRefresh()
     *
     * @param parameters The global parameters for the hierarchy.
     */
    private void foregroundActivity(PlaceParameters parameters) {
        if (activity instanceof SlottedActivity) {
            currentProtectedDisplay = new ProtectedDisplay(activity, true);

            //todo is this needed
            ActivityCache activityCache = slottedController.getActivityCache();
            activityCache.add(place, activity);

            SlottedActivity slottedActivity = (SlottedActivity) activity;
            boolean success = slot.foreground(activity);
            if (success) {
                slottedActivity.onRefresh();
            } else {
                getStartActivity(parameters);
            }
        }
    }

    /**
     * Calls onRefresh() if the current Activity is a SlottedActivity.
     *
     * @param parameters The global parameters for the hierarchy.
     */
    private void refreshActivity(PlaceParameters parameters) {
        if (activity instanceof SlottedActivity) {
            //todo is this needed
            ActivityCache activityCache = slottedController.getActivityCache();
            activityCache.add(place, activity);

            SlottedActivity slottedActivity = (SlottedActivity) activity;
            slottedActivity.init(slottedController, place, parameters, resettableEventBus, this);
            slottedActivity.onRefresh();
        }
    }

    /**
     * Creates the child ActiveSlots for the Place's child Slots.
     */
    private void createChildren() {
        Slot[] childSlots = place.getChildSlots();
        if (childSlots != null && childSlots.length > 0 && children.isEmpty()) {
            for (Slot child: childSlots) {
                ActiveSlot activeSlot =  new ActiveSlot(this, child, resettableEventBus, slottedController);
                children.add(activeSlot);
            }
            assert childSlots.length == children.size() : "Error creating children ActiveSlots";
        }
    }

    /**
     * Sets the loading state of this Slot.  This is used in the delayed loading feature.
     *
     * @param loading True if the loading is starting, or false if loading is complete
     * @param activity The Activity attempting to set the loading state.  If the Activity doesn't match
     *                 the current Activity, the call is ignored.
     */
    public void setLoading(boolean loading, SlottedActivity activity) {
        if (currentProtectedDisplay != null && currentProtectedDisplay.activity == activity) {
            currentProtectedDisplay.loading = loading;
            if (loading) {
                slottedController.showLoading();
            } else {
                slottedController.attemptShowViews();
            }
        }
    }

    /**
     * @return True if the slot's activity called setLoadingStarted() without completing.
     */
    public boolean isLoading() {
        return currentProtectedDisplay != null && currentProtectedDisplay.loading;
    }

    /**
     * Recursively checks the hierarchy to find a Slot that is blocking displaying Activities.
     *
     * @return The ActiveSlot for the Slot that is loading.
     */
    public ActiveSlot getFirstBlockingSlot() {
        if (currentProtectedDisplay == null || currentProtectedDisplay.loading) {
            return this;
        }
        if (children!= null) {
            for (ActiveSlot child: children) {
                ActiveSlot childSlot = child.getFirstBlockingSlot();
                if (childSlot != null) {
                    return childSlot;
                }
            }
        }
        return null;
    }

    /**
     * Shows all the views in the hierarchy.  This is called after all the Slots have completed loading.
     *
     * @throws IllegalStateException If any of the ActiveSlots are in a loading state.
     */
    public void showViews() {
        if (currentProtectedDisplay == null || currentProtectedDisplay.loading) {
            throw new IllegalStateException("Attempting to show a view for a loading slot:" + place);
        }
        currentProtectedDisplay.showWidget();
        if (children!= null) {
            for (ActiveSlot child: children) {
                child.showViews();
            }
        }
        if (activity instanceof SlottedActivity) {
            ((SlottedActivity) activity).onLoadComplete();
        }
    }

    /**
     * Gets the parent for this ActiveSlot.
     */
    public ActiveSlot getParent() {
        return parent;
    }

    /**
     * Gets all the child ActiveSlots that this ActiveSlot manages.
     */
    public ArrayList<ActiveSlot> getChildren() {
        return children;
    }

    /**
     * Gets the current Slot that this ActiveSlot represents
     */
    public Slot getSlot() {
        return slot;
    }

    /**
     * Gets the ResettableEventBus being used.
     * @return {@link ResettableEventBus}
     */
    public EventBus getEventBus() {
        return resettableEventBus;
    }

    /**
     * The current Place be displayed in this Slot
     */
    public SlottedPlace getPlace() {
        return place;
    }

    /**
     * The current Activity being display by this Slot
     */
    public Activity getActivity() {
        return activity;
    }

}
